import { createWriteStream } from 'fs';
import { stat } from 'fs/promises';
import { resolve, relative } from 'path';
import archiver from 'archiver';
import { ensureDir, writeJson, writeText } from '../utils/fs.js';
import { isoTimestamp } from '../utils/time.js';

function appendFileIfExists(archive, filePath, entryName) {
  if (!filePath) {
    return;
  }
  archive.file(filePath, { name: entryName });
}

/**
 * Create Stitch-compatible export bundle with manifest and rationale notes.
 * @param {object} params
 */
export async function createStitchExportBundle({
  runTimestamp,
  runRoot,
  taskId,
  locales,
  baselineLocale,
  ingestion,
  copy,
  media,
  ux,
  changeLog,
  preview,
  reviewer,
  sourcePath,
  copySummary,
  mediaSummary,
  uxSummary,
}) {
  const exportRoot = resolve(process.cwd(), 'exports', 'localization-mvp', runTimestamp);
  await ensureDir(exportRoot);

  const bundlePath = resolve(exportRoot, 'localized-page.zip');
  const manifestPath = resolve(exportRoot, 'manifest.json');
  const rationalePath = resolve(exportRoot, 'rationale.md');

  const archive = archiver('zip', { zlib: { level: 9 } });
  const output = createWriteStream(bundlePath);

  const finalizePromise = new Promise((resolvePromise, rejectPromise) => {
    output.on('close', resolvePromise);
    output.on('error', rejectPromise);
  });

  archive.on('error', (error) => {
    throw error;
  });

  archive.pipe(output);

  appendFileIfExists(archive, ingestion?.screenshotPath, 'preview/base.png');
  appendFileIfExists(archive, ingestion?.domPath, 'dom/original.html');
  appendFileIfExists(archive, ingestion?.manifestPath, 'dom/manifest.json');
  appendFileIfExists(archive, copy?.outputPath, 'agents/copy.json');
  appendFileIfExists(archive, media?.outputPath, 'agents/media.json');
  appendFileIfExists(archive, ux?.outputPath, 'agents/ux.json');
  appendFileIfExists(archive, changeLog?.changelogPath, 'changelog/changelog.yaml');
  appendFileIfExists(archive, changeLog?.manifestPath, 'changelog/manifest.json');
  appendFileIfExists(archive, preview?.metadataPath, 'preview/metadata.json');
  appendFileIfExists(archive, preview?.notesPath, 'preview/notes.txt');

  const pendingReview = {
    copy: copySummary?.totals?.requiresReview ?? 0,
    media: mediaSummary?.totals?.requiresReview ?? 0,
    ux: uxSummary?.totals?.requiresReview ?? 0,
  };

  const rationaleLines = [
    '# Stitch Bundle Rationale',
    '',
    `Generated: ${isoTimestamp()}`,
    `Task: ${taskId}`,
    `Run: ${runTimestamp}`,
    '',
    '## Summary',
    '',
    `- Locales packaged: ${locales.join(', ')}`,
    `- Baseline locale: ${baselineLocale}`,
    `- Reviewer on record: ${reviewer.name} (${reviewer.id})`,
    `- Copy diffs accepted: ${copySummary?.totals?.changed ?? 0}`,
    `- Items pending human review â†’ copy: ${pendingReview.copy}, media: ${pendingReview.media}, ux: ${pendingReview.ux}`,
    '',
    '## Next Review Notes',
    '',
    '- Resolve pending Japanese compliance approvals before public pilot.',
    '- Validate media asset licensing for UK and Japanese hero swaps.',
    '- Confirm UX typography updates align with design system tokens.',
    '',
    '## File Manifest',
    '',
    '- `preview/base.png`: Baseline canvas capture for reviewers.',
    '- `dom/original.html`: Hydrated DOM used for diffing.',
    '- `agents/*.json`: Agent payloads for copy, media, and UX recommendations.',
    '- `changelog/changelog.yaml`: Reviewer decisions with compliance notes.',
    '- `preview/metadata.json`: Canvas rendering metadata for QA. ',
    '',
    'All assets generated by the automated phase-2 pipeline.',
    '',
  ].join('\n');

  archive.append(rationaleLines, { name: 'notes/rationale.md' });

  await archive.finalize();
  await finalizePromise;

  await writeText(rationalePath, rationaleLines);

  const { size: bundleSize } = await stat(bundlePath);

  const manifest = {
    taskId,
    runId: runTimestamp,
    generatedAt: isoTimestamp(),
    baselineLocale,
    locales,
    reviewer,
    source: {
      path: relative(process.cwd(), sourcePath),
    },
    pendingReview,
    artifacts: {
      bundle: relative(process.cwd(), bundlePath),
      rationale: relative(process.cwd(), rationalePath),
      changelog: relative(process.cwd(), changeLog?.changelogPath ?? ''),
      screenshot: relative(process.cwd(), ingestion?.screenshotPath ?? ''),
    },
    metrics: {
      bundleSizeBytes: bundleSize,
      copyChanges: copySummary?.totals?.changed ?? 0,
      mediaRecommendations: mediaSummary?.totals?.total ?? 0,
      uxRecommendations: uxSummary?.totals?.total ?? 0,
    },
  };

  await writeJson(manifestPath, manifest);

  return {
    bundlePath,
    manifestPath,
    rationalePath,
    manifest,
    relativeBundlePath: relative(process.cwd(), bundlePath),
    relativeManifestPath: relative(process.cwd(), manifestPath),
    relativeRationalePath: relative(process.cwd(), rationalePath),
  };
}
